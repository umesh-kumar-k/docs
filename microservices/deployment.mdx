Azure microservices deployment architectures revolve around safe, incremental rollout strategies (rolling, blue‑green, canary, shadow) plus good service‑instance placement patterns (per‑container, per‑VM, serverless) to maximize availability and reduce risk.[1][2]

## Use cases and key patterns

- **When these patterns matter**  
  - High‑availability, always‑on systems (e‑commerce, fintech, SaaS) where any downtime or bad release has high cost, and microservices are deployed many times per day.[3][4][1]
  - Complex microservice estates where each service can be updated independently, but you still need system‑level safety and predictable rollback.[4][5][1]

- **Core deployment strategies**  
  - **Rolling deployments** – update one batch of instances at a time; traffic stays on the same fleet while pods/instances are gradually replaced. Good default for stateless microservices.[6][1]
  - **Blue‑green deployments** – run two production environments (Blue=current, Green=new); switch traffic to Green in one shot, with instant rollback by switching back.[7][1][4]
  - **Canary releases** – send a small percentage of traffic/users to the new version, monitor, then gradually ramp up if healthy.[8][1][4]
  - **Shadow deployments** – send a copy of real traffic to the new version “in the shadows” (responses ignored) to validate behavior and performance before exposing users.[1][6]

## Related design/deployment patterns

- **Service instance deployment** (microservices.io)  
  - Multiple service instances per host vs service instance per VM vs service instance per container vs serverless; modern practice is “service instance per container” or serverless for isolation and scaling.[2]
  - Service deployment platform: use AKS/EKS or serverless containers (Azure Container Apps, AWS Fargate/App Runner) plus CI/CD to automate rollout.[2][1]

- **Feature flags & A/B testing**  
  - Feature flags decouple code deployment from feature exposure, often combined with canary/blue‑green for finer control.[4][1]
  - A/B testing: route subsets of users to different versions to compare performance or UX, often layered on gateway or service mesh.[9][1]

- **Observability‑driven deployment**  
  - Success depends on metrics, logs, and traces during rollout; OpsLevel/OSO articles stress deep monitoring and automated rollback triggers.[5][3][1]

## Azure vs AWS implementation

- **Azure**  
  - Compute: AKS, Azure Container Apps, App Service, Functions; all support rolling, blue‑green, and canary strategies via orchestrator and gateway.[10][11][7]
  - **Rolling**: native Kubernetes rolling updates on AKS (Deployments), rolling slots on App Service, and versioned revisions on Container Apps.[11][12][10]
  - **Blue‑green**: two AKS clusters or namespaces behind Application Gateway/Front Door; DNS CNAME switch or gateway routing to flip from Blue to Green.[13][7]
  - **Canary**: APIM/App Gateway/Ingress can route a small percentage of traffic to the new version (labels, revisions, or header‑based routing), then ramp up using metrics from Azure Monitor/App Insights.[14][7][4]

- **AWS**  
  - Compute: EKS, ECS/Fargate, App Runner, Lambda; deployment strategies integrated with CodeDeploy/CodePipeline and API Gateway/ALB.[15][9]
  - **Rolling**: default in ECS/EKS deployments (replace tasks/pods in batches).[16][9]
  - **Blue‑green**: separate target groups/Auto Scaling groups or stacks; CodeDeploy and load balancers switch traffic between old and new.[17][9]
  - **Canary**: CodeDeploy and Lambda/ALB/APIGW support weighted traffic shifting; AWS docs describe canary as a risk‑averse blue‑green variant.[8][9]

Concepts are the same: Azure leans on AKS/Container Apps/App Service + APIM/App Gateway; AWS leans on EKS/ECS/App Runner/Lambda + API Gateway/ALB, with platform‑native deployment controllers.[10][15][1]

## Cheat‑sheet (Q&A style)

**Q1: What are the main microservice deployment strategies you should know?**  
A: Rolling, Blue‑green, Canary, and Shadow deployments; optionally A/B testing layered on top.[6][1][4]

**Q2: When would you use rolling deployments?**  
A: As the default for stateless services where small, incremental updates with minimal extra infra are acceptable; good balance of risk and cost.[9][1]

**Q3: When is blue‑green preferred?**  
A: For strict uptime and fast rollback requirements—run two prod environments and flip traffic via DNS/gateway; trade‑off is higher infra cost.[14][7][4]

**Q4: When is canary better than pure blue‑green?**  
A: For high‑traffic systems where you want to gradually expose a new version to a small user slice, monitor real‑world behavior, and then ramp up if healthy.[1][4][8]

**Q5: What is a shadow deployment useful for?**  
A: For testing complex or risky changes using real traffic mirrored to a new version without impacting users; great for performance/regression analysis.[6][1]

**Q6: How would you implement these on Azure?**  
A: Use AKS/Container Apps/App Service with Azure DevOps/GitHub Actions CI/CD; rolling via Kubernetes/App Service, blue‑green via dual clusters/slots and Application Gateway/Front Door, canary via APIM/App Gateway traffic splitting and metrics‑based gates.[7][11][14][10]

**Q7: What’s the AWS equivalent implementation?**  
A: Use EKS/ECS/App Runner/Lambda with CodePipeline/CodeDeploy; rolling as default, blue‑green via separate target groups/Auto Scaling groups, and canary via weighted routing in CodeDeploy/API Gateway/ALB.[15][8][9]

**Q8: What are key trade‑offs between these strategies?**  
A: Rolling: simple, low cost, slower detection; Blue‑green: zero‑downtime and fast rollback but doubles infra; Canary: best risk control and feedback, but more complexity in routing and analysis; Shadow: very safe but adds extra processing and requires robust observability.[4][9][1]

**Q9: How do microservice deployment patterns interact with data/compatibility?**  
A: Need backward‑compatible schema/API changes, versioned contracts, and often event sourcing/outbox patterns to avoid data mismatches when multiple versions run concurrently.[18][1]

**Q10: Example interview narrative?**  
A: “We deploy microservices on AKS via CI/CD; default is rolling updates; for critical services we use blue‑green with dual clusters and DNS flip, plus canary routing in APIM for gradual exposure; observability decides rollback; on AWS the same design would use EKS/ECS with CodeDeploy and weighted ALB/API Gateway routing.”[10][7][9][1]

## Data structures & algorithms

- **Data structures**  
  - Deployment specifications (Kubernetes manifests, Helm charts, ARM/Bicep, CloudFormation/CDK) describing versions, replica counts, and environments.[7][1]
  - Routing/weighting configs in gateways/ALBs for canary and A/B (percent weights per version, header or cookie‑based routing rules).[8][9][1]

- **Algorithms / techniques**  
  - Traﬃc shifting: weighted routing (for example 1%, 10%, 50%, 100%) in gateways/load balancers.[9][1][8]
  - Rolling update controllers and health‑based rollback: orchestrators update batches and roll back if health checks fail.[1][6]
  - Metrics‑driven gates: compare error rate, latency, and saturation vs SLOs to automatically advance or abort deployment.[4][1]

Most “algorithms” are policies around weighting, health checking, and rollback rather than complex DS/Algo.[9][1]

## Tools / frameworks / software

- **Azure**  
  - AKS, Azure Container Apps, App Service, Functions; Azure DevOps/GitHub Actions, ACR; Azure API Management, Application Gateway, Front Door; Azure Monitor/App Insights for deployment health.[11][14][10][7]

- **AWS**  
  - EKS, ECS/Fargate, App Runner, Lambda; CodePipeline/CodeDeploy; ALB/NLB, API Gateway; CloudWatch/X‑Ray, deployment controllers for rolling/blue‑green/canary.[17][15][9]

- **General**  
  - Kubernetes + Helm, Argo Rollouts/Spinnaker/Harness for progressive delivery; Prometheus/Grafana for monitoring; OpsLevel and similar portals to track deployment patterns and service health.[5][1]

## Concise bullet summary (keywords & terms)

- Deployment strategies: **rolling**, **blue‑green**, **canary**, **shadow**, **A/B**.[6][1][4]
- Availability focus: detect issues early, limit blast radius, enable fast rollback, and maintain zero‑ or near‑zero downtime.[3][1]
- Azure: AKS/Container Apps/App Service + APIM/App Gateway/Front Door + Azure DevOps/GitHub Actions + Monitor.[14][11][10][7]
- AWS: EKS/ECS/App Runner/Lambda + CodeDeploy/CodePipeline + API Gateway/ALB/NLB + CloudWatch.[17][15][9]
- Supporting patterns: service instance per container/serverless, feature flags, observability‑driven rollouts, versioned APIs and schemas.[18][2][1]

[1](https://www.osohq.com/learn/microservices-deployment)
[2](https://microservices.io/patterns/)
[3](https://www.opslevel.com/resources/4-microservice-deployment-patterns-that-improve-availability)
[4](https://www.wissen.com/blog/the-role-of-blue-green-canary-and-feature-flags)
[5](https://www.opslevel.com/resources/a-complete-guide-to-microservice-orchestration)
[6](https://www.youtube.com/watch?v=9DS1UyPzIqk)
[7](https://learn.microsoft.com/en-us/azure/architecture/guide/aks/blue-green-deployment-for-aks)
[8](https://docs.aws.amazon.com/whitepapers/latest/overview-deployment-options/canary-deployments.html)
[9](https://dev.to/aws-builders/mastering-deployment-strategies-on-aws-big-bang-rolling-blue-green-and-canary-explained-384f)
[10](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices)
[11](https://learn.microsoft.com/en-us/azure/architecture/microservices/design/compute-options)
[12](https://learn.microsoft.com/en-us/azure/container-apps/compare-options)
[13](https://learn.microsoft.com/en-us/answers/questions/1663497/i-want-to-perform-blue-green-or-canary-deployments)
[14](https://vishwasacharya.hashnode.dev/azure-devops-deployment-strategies-bluegreen-vs-canary)
[15](https://aws.amazon.com/containers/)
[16](https://www.bmc.com/blogs/aws-ecs-vs-eks/)
[17](https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/deployment-strategies.html)
[18](https://www.osohq.com/learn/microservices-best-practices)
[19](https://www.opslevel.com)
[20](https://www.opslevel.com/resource-topics/insights?5a6c3de5_page=2)
[21](https://www.opslevel.com/resource-topics/campaigns)
[22](https://www.opslevel.com/resource-topics/tooling?5a6c3de5_page=2)
[23](https://dl.acm.org/doi/abs/10.1145/3696348.3702013)
[24](https://www.openlegacy.com/blog/microservices-architecture-patterns/)
[25](https://www.harness.io/blog/blue-green-canary-deployment-strategies)