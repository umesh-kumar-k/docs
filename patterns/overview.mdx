Below is a compact, pattern‑by‑pattern cheat sheet for backend/system‑design interviews (Java/Spring, services, etc.). Each entry: intent, typical use case, pros/cons, and an interview‑style note.[1][2][3][4]

***

## Creational Patterns

### Factory Method

- **Intent**: Let a base class define a **factory method** for creating products, while subclasses decide which concrete product to return.[1]
- **Use case**: `Dialog.createButton()` returning platform‑specific `Button` (Windows/Mac), or `RoadLogistics.createTransport()` returning `Truck` vs `SeaLogistics` returning `Ship`.[1]
- **Pros**: Decouples client from concrete classes; centralizes construction; easy to add new product types by adding new creator subclasses.[1]
- **Cons**: Extra subclass hierarchy and indirection; can proliferate creators.[1]
- **Interview angle**: “When adding a new transport type, what changes?” → Only create a new `Logistics` subclass and override factory, no client changes (Open/Closed).[1]

***

### Abstract Factory

- **Intent**: Create **families of related objects** (e.g., all “Modern” UI widgets) without specifying concrete classes.[2]
- **Use case**: `UIFactory` with `createButton()/createCheckbox()`; `WindowsUIFactory` vs `MacUIFactory` returning consistent UI sets; or furniture sets `ModernChair/ModernSofa`.[2]
- **Pros**: Ensures products from a family are compatible; hides concrete variants behind interfaces; easy to add new families (new concrete factories).[2]
- **Cons**: Many interfaces and factory classes; more complex than Factory Method.[2]
- **Interview angle**: Compare to Factory Method—Abstract Factory manages **multiple related products per family**, not just one.[2]

***

### Builder

- **Intent**: Construct **complex objects step‑by‑step**, optionally producing different representations with the same process.[4]
- **Use case**: Building complex DTOs, configuration objects, or SQL queries; building HTTP requests or domain aggregates with many optional fields.[4]
- **Pros**: Readable chained construction, separates construction logic from representation, avoids telescoping constructors.[4]
- **Cons**: Extra classes; can be overkill for simple objects.[4]
- **Interview angle**: “When do you choose Builder over telescoping constructors or Factory?” → Many optional params or different construction paths for same type.[4]

***

### Prototype

- **Intent**: Create objects by **cloning existing prototypes** instead of using `new` from scratch.[4]
- **Use case**: Duplicating expensive‑to‑create objects (preconfigured documents, trees, configuration graphs), or polymorphic copies when you don’t know concrete types.[4]
- **Pros**: Avoids costly re‑creation; can clone at runtime without depending on concrete class.[4]
- **Cons**: Deep/shallow copy complexity; ensuring correct clone semantics.[4]
- **Interview angle**: “Prototype vs Factory?” → Factory builds from scratch, Prototype clones an existing instance.[4]

***

### Singleton

- **Intent**: Guarantee a **single instance** with global access.[4]
- **Use case**: Configuration registry, connection pool manager, logging facade.[4]
- **Pros**: Simple access to shared resource; lazy init possible.[4]
- **Cons**: Global mutable state, hidden dependencies, hard to test; often considered an anti‑pattern.[4]
- **Interview angle**: “When avoid Singleton?” → When DI/container can manage lifetimes; prefer injecting dependencies.[4]

***

## Structural Patterns

### Adapter

- **Intent**: Convert one interface into another **expected** by clients.[4]
- **Use case**: Wrap legacy service or third‑party API to match your internal port interface; adapting payment gateways or external HTTP clients.[4]
- **Pros**: Integrates incompatible APIs without touching client code; isolates vendor changes.[4]
- **Cons**: More layers; if misused can hide poor domain modeling.[4]
- **Interview angle**: “How to plug a new payments provider without touching domain logic?” → Implement an Adapter to your `PaymentPort`.[4]

***

### Bridge

- **Intent**: **Decouple abstraction from implementation** so they can vary independently.[4]
- **Use case**: `RemoteControl` abstraction with various `Device` implementations (TV, Radio); or persistence abstraction with different databases.[4]
- **Pros**: Avoids combinatorial explosion of subclasses; supports switching implementations at runtime.[4]
- **Cons**: Extra indirection; can feel abstract if overused.[4]
- **Interview angle**: Compare to Adapter—Bridge is **designed up‑front** to separate dimensions; Adapter is reactive integration.[4]

***

### Composite

- **Intent**: Treat individual objects and **hierarchies (trees)** uniformly.[4]
- **Use case**: File system (file vs folder), UI component tree, organization hierarchy.[4]
- **Pros**: Uniform operations on leaves and composites; simplifies recursive logic.[4]
- **Cons**: Can blur differences between leaf/composite responsibilities.[4]
- **Interview angle**: “How would you model a menu tree or ACL hierarchy?” → Composite of nodes implementing common interface.[4]

***

### Decorator

- **Intent**: Attach **additional responsibilities dynamically** by wrapping objects, instead of subclassing.[4]
- **Use case**: Add caching, logging, metrics, encryption to repositories or services; HTTP client wrappers.[4]
- **Pros**: Composable behaviors; avoids subclass explosion; open for extension.[4]
- **Cons**: Deep wrapper stacks can be hard to debug; care needed for identity/equality.[4]
- **Interview angle**: “How to add caching to a repository without modifying it?” → Decorator implementing same interface and delegating.[4]

***

### Facade

- **Intent**: Provide a **simple API over a complex subsystem**.[4]
- **Use case**: `OrderFacade.placeOrder()` hides orchestration across inventory, payments, notifications; simplifies use for controllers.[2][4]
- **Pros**: Shields clients from complexity; centralizes orchestration; good seam for testing.[4]
- **Cons**: Can become a “god object” if it grows too broad.[4]
- **Interview angle**: Distinguish from Abstract Factory—Facade simplifies **usage** of subsystem, Abstract Factory simplifies **creation**.[2]

***

### Flyweight

- **Intent**: Share **heavy intrinsic state** among many objects, keeping only extrinsic state per instance.[4]
- **Use case**: Large numbers of similar value objects that share configuration, fonts, metadata; caching immutable domain objects.[4]
- **Pros**: Drastically reduces memory footprint.[4]
- **Cons**: More complex lifecycle and identity semantics.[4]
- **Interview angle**: “How to handle millions of nearly identical nodes?” → Flyweight + indexing extrinsic data.[4]

***

### Proxy

- **Intent**: Provide a **surrogate** that controls access to a real object (remote, lazy, protected, cached).[4]
- **Use case**: Remote proxies (RPC stub), lazy loading, security checks, caching/protection proxies on repositories.[4]
- **Pros**: Cross‑cutting concerns at the boundary; works well with AOP/DI.[4]
- **Cons**: Can obscure control flow; debugging goes through extra layers.[4]
- **Interview angle**: Differentiate from Decorator—Proxy focuses on **access control/indirection**, Decorator on **adding behavior**.[4]

***

## Behavioral Patterns

### Chain of Responsibility

- **Intent**: Pass a request along a **chain of handlers** until one handles it.[4]
- **Use case**: HTTP middleware, validation pipelines, approval workflows.[4]
- **Pros**: Flexible handler ordering; easy to add/remove steps.[4]
- **Cons**: Harder to trace which handler processed what; termination conditions must be clear.[4]

***

### Command

- **Intent**: Encapsulate **requests as objects** (with `execute` and often `undo`).[4]
- **Use case**: Task queues, undo/redo in editors, audit logging of operations.[4]
- **Pros**: Queue, log, replay operations; decouples invoker from receiver.[4]
- **Cons**: Many small classes; need to think about idempotency and serialization.[4]

***

### Iterator

- **Intent**: Provide a standard way to **traverse collections** without exposing internal structure.[4]
- **Use case**: Encapsulate traversal over custom aggregates (trees, graph results).[4]
- **Pros**: Simplifies traversal; supports multiple traversal strategies.[4]
- **Cons**: In languages with built‑in iterators, explicit pattern is less visible.[4]

***

### Mediator

- **Intent**: Centralize **communications between objects**, reducing direct coupling.[4]
- **Use case**: Chat room server, event bus within a module, coordinating UI widgets.[4]
- **Pros**: Simpler participants; interactions isolated in mediator.[4]
- **Cons**: Mediator can grow complex, effectively a “god object”.[4]

***

### Memento

- **Intent**: Capture and restore an object’s **internal state** without exposing its internals.[4]
- **Use case**: Undo/redo, checkpoints in workflows.[4]
- **Pros**: Encapsulated snapshots; originator remains encapsulated.[4]
- **Cons**: Memory overhead storing snapshots; security concerns if state is sensitive.[4]

***

### Observer

- **Intent**: Let objects **subscribe** to events and get notified on state changes.[4]
- **Use case**: Domain events, pub/sub in microservices, event sourcing subscribers.[4]
- **Pros**: Loose coupling between publishers and subscribers.[4]
- **Cons**: Event storms, ordering issues, harder debugging.[4]

***

### State

- **Intent**: Let an object **change its behavior** when its internal state changes by delegating to state objects.[4]
- **Use case**: Order lifecycle (NEW → PAID → SHIPPED), connection lifecycle, workflow engines.[4]
- **Pros**: Avoids big `switch` on state; each state encapsulates rules.[4]
- **Cons**: Many small state classes; a bit heavyweight for simple workflows.[4]

***

### Strategy

- **Intent**: Define a family of **algorithms** and make them interchangeable at runtime via a common interface.[3]
- **Use case**: Different pricing strategies, routing algorithms, serialization strategies.[3]
- **Pros**: Replaces conditionals over algorithm choice; easy to extend.[3]
- **Cons**: More classes; client must know which strategy to pick (or use a factory).[3]

***

### Template Method

- **Intent**: Define **skeleton of an algorithm** in a base class, allowing subclasses to override specific steps.[1][4]
- **Use case**: Abstract job runners, framework hooks for request handling or lifecycle events.[4]
- **Pros**: Code reuse; enforces sequence while allowing variation in steps.[4]
- **Cons**: Inflexible inheritance‑based reuse; can drift into fragile base class.[4]

***

### Visitor

- **Intent**: Separate **operations from data structures**, allowing adding new operations without changing element classes.[4]
- **Use case**: AST processing (compilers), reporting over object graphs, cross‑cutting traversals.[4]
- **Pros**: Easy to add new operations; centralizes traversal logic.[4]
- **Cons**: Adding new element types requires updating all visitors.[4]

***

## Quick Interview Checklist

- **Creational**:  
  - Factory Method vs Abstract Factory vs Builder vs Prototype vs Singleton.[1][2][4]
- **Structural**:  
  - Adapter vs Bridge vs Facade vs Proxy vs Decorator vs Composite vs Flyweight.[4]
- **Behavioral**:  
  - Strategy vs State vs Template Method vs Command vs Chain vs Observer vs Mediator vs Visitor vs Memento vs Iterator.[3][4]

[1](https://refactoring.guru/design-patterns/factory-method)
[2](https://refactoring.guru/design-patterns/abstract-factory)
[3](https://refactoring.guru/design-patterns/strategy)
[4](https://refactoring.guru)
[5](https://refactoring.guru/replace-constructor-with-factory-method)
[6](https://www.reddit.com/r/csharp/comments/pvz5r1/trying_to_understand_factory_method_from_this/)
[7](https://www.reddit.com/r/learnprogramming/comments/1bikubq/difference_between_factory_method_and_abstract/)
[8](https://www.ombulabs.com/blog/code-refactor/refactoring-with-design-patterns.html)
[9](https://sourcemaking.com)
[10](https://www.reddit.com/r/cpp/comments/qvsdu0/factory_method_why_create_a_separate_class_for/)
[11](https://officialcto.com/interview-section/refactoring/patterns-principles)
[12](https://springframework.guru/gang-of-four-design-patterns/)
[13](https://www.youtube.com/watch?v=J9xiplE49ow)
[14](https://github.com/barneydellar/RefactoringToTheStrategyPattern)
[15](https://github.com/HugoMatilla/Refactoring-Summary)
[16](https://www.tracylum.com/blog/2017-03-17-refactoring-with-the-strategy-pattern/)
[17](https://www.reddit.com/r/softwaredevelopment/comments/18q1147/software_design_patterns/)
[18](https://stackoverflow.com/questions/78428798/understanding-factory-design-pattern-in-python)
[19](https://www.geeksforgeeks.org/system-design/strategy-pattern-set-1/)
[20](https://sourcemaking.com/design_patterns)
[21](https://www.reddit.com/r/csharp/comments/sdfqq1/factory_method_design_pattern_in_c/)