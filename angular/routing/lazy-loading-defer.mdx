Angular’s `@defer` lets you lazy‑load standalone components (and their chunks) directly from templates with rich control over *when* they load (triggers), *how* they preload (prefetch), and what to show before/during/after loading (`@placeholder`, `@loading`, `@error`), complementing but not replacing router‑based lazy loading.[1][2][3]

***

## Core mechanics & prerequisites

- Works only with **standalone components**; each deferred component should live in its own file and not be eagerly imported elsewhere (to keep the chunk split).[3][1]
- Basic usage:
  ```html
  @defer {
    <my-org-heavy />
  }
  ```
  → compiler moves `my-org-heavy` into its own lazy JS chunk, loaded when the parent template runs (default `on idle`).[1][3]
- You can wrap **multiple** standalone components in a single `@defer`; their chunks load together when the block triggers.[1]

***

## Triggers: when to load

Two trigger styles:

- **Declarative `on`** (most common):  
  `@defer (on <trigger>) { ... }`  
  - `on immediate` – load as soon as parent template runs.[3]
  - `on idle` (default) – load on first `requestIdleCallback`.[3][1]
  - `on timer(ms)` – after delay (use *with* another trigger like `on viewport`).[1][3]
  - `on viewport (target?)` – when placeholder or optional `#target` hits viewport (IntersectionObserver).[3][1]
  - `on hover (target?)` – on `mouseenter`/`focusin`.[1][3]
  - `on interaction (target?)` – on `click`/`keydown`.[3][1]

- **Imperative `when`**:  
  `@defer (when expr) { ... }` where `expr` is any boolean expression (field, method, signal, `stream$ | async`).[1][3]  
  - One‑way: once `true`, block loads and stays loaded even if condition later becomes false.[1]

Multiple triggers are OR‑ed:  
`@defer (on viewport; on timer(2s)) { ... }`.[1]

***

## Prefetch: when to pre‑download the chunk

- Syntax: `@defer (on trigger; prefetch on otherTrigger) { ... }`.[3][1]
- Same trigger set (`on idle`, `on timer`, `on viewport`, `on hover`, `on interaction`, `when`) but for **prefetching only**:
  - Prefetch can warm the cache early (e.g. `prefetch on idle`) while actual render waits for `on interaction` or `on viewport`.[3][1]
- If the main trigger fires and chunk is already prefetched, `@loading` usually won’t appear (nothing to load).[1]

***

## Sub‑blocks: UX for defer states

```html
@defer (on viewport; prefetch on timer(2000)) {
  <my-org-chart />
} @placeholder {
  <my-org-skeleton type="chart" />
} @loading(after: 100ms; minimum: 500ms) {
  <my-org-skeleton type="chart" [animate]="true" />
} @error {
  <my-org-error-feedback />
}
```


- **`@placeholder`** – shown *before* loading starts; can have `minimum: duration`.[1][6]
- **`@loading`** – shown *during* bundle load; options:
  - `after: duration` – only show if loading took at least this long.  
  - `minimum: duration` – keep visible at least this long.[3][1]
- **`@error`** – shown if the chunk fails to load; currently no detailed error injection or retry API.[1][3]
- Dependencies used in `@placeholder/@loading/@error` are **eagerly loaded**; only content inside main `@defer` is lazy.[3][1]

Key interactions:  
- Placeholder with `minimum` + very fast load → `@loading` may never show.  
- `on immediate` + `@loading` → placeholder likely never visible.  
- Prefetched chunk → `@loading` often skipped.[1]

***

## Router vs `@defer`

- Router lazy routes: coarse‑grained **page/feature** splitting, URL‑driven state, SEO/deep‑linking.[1]
- `@defer`: fine‑grained **in‑page** lazy loading (charts, editors, heavy widgets) *within* a lazy route.[3][1]
- They are complementary: use router for feature slices, `@defer` for heavy sub‑components.[1]

***

## Testing `@defer`

- Angular TestBed exposes defer block fixtures:
  - `fixture.getDeferBlocks()` → list of block fixtures.[3][1]
  - Each fixture: `.render(DeferBlockState.Placeholder | Loading | Complete | Error)` to force specific state in tests.[1][3]

***

## Best practices & patterns

- Use `@placeholder` **always**; strongly prefer skeleton UI that closely matches final component to avoid layout jumps.[1]
- Make `@placeholder` and `@loading` look nearly identical (e.g. same skeleton, `@loading` adds animation) to minimize visual noise.[1]
- Often **omit `minimum` on placeholder** so real content appears as soon as possible; avoid showing `spinner → skeleton → chart` cascades.[1]
- Don’t `@defer` “everything”; target **heavy** components (charts, editors, large widgets). Deferring every nested child creates request waterfalls and slower overall load.[1]
- Choose triggers based on cost:
  - Expensive to *run* (extra HTTP, heavy compute): `prefetch on timer/idle` + `on viewport` or `on interaction`.  
  - Cheap: you can use `on timer` alone, but combine with `on viewport`/`on hover` to avoid user arriving before timer fires.[1]

***

## Interview cheat sheet (Q & A)

- **Q: What does `@defer` do differently from router lazy loading?**  
  A: Router lazy‑loads *routes*; `@defer` lazy‑loads *standalone components inside a route*, with template‑level control over triggers, prefetch, and UX states.[3][1]

- **Q: What are the main trigger types?**  
  A: Declarative `on` (`immediate`, `idle`, `timer`, `viewport`, `hover`, `interaction`) and imperative `when condition`; all OR‑combined when multiple are used.[3][1]

- **Q: How do `prefetch` and main triggers interact?**  
  A: `prefetch` can download the chunk earlier; when the main trigger fires, if bundle is already cached, content renders directly and `@loading` often doesn’t appear.[3][1]

- **Q: What is the role of `@placeholder`, `@loading`, `@error`?**  
  A: `@placeholder` shows before loading starts; `@loading` during network fetch with `after`/`minimum` tuning; `@error` on load failure, with eagerly loaded dependencies.[3][1]

- **Q: When should you *not* use `@defer`?**  
  A: Avoid deferring small/light components or every nested child; reserve it for clearly heavy pieces where chunk splitting materially improves time‑to‑interactive.[1]

***

## Key terms & keywords (quick scan)

- `@defer`, deferred views  
- Declarative triggers: `on idle`, `on viewport`, `on interaction`, `on hover`, `on timer`, `on immediate`  
- Imperative trigger: `when condition`  
- `prefetch on ...`, `prefetch when ...`  
- `@placeholder` (`minimum`), `@loading` (`after`, `minimum`), `@error`  
- Multiple components per `@defer` block  
- Standalone components, lazy chunks  
- Router lazy loading vs `@defer`  
- `DeferBlockState` (`Placeholder`, `Loading`, `Complete`, `Error`) for testing

[1](https://angularexperts.io/blog/angular-defer-lazy-loading-total-guide)
[2](https://angularexperts.io/blog/angular-defer-lazy-loading-total-guide/)
[3](https://angular.dev/guide/templates/defer)
[4](https://blog.angular-university.io/angular-defer/)
[5](https://www.geeksforgeeks.org/angular-js/implementing-lazy-loading-in-angular/)
[6](https://blog.logrocket.com/using-defer-angular-17-implement-lazy-loading/)
[7](https://angular.dev/api/core/@defer)
[8](https://dev.to/this-is-angular/boosting-angular-performance-with-defer-and-lazy-loading-40f3)
[9](https://www.youtube.com/watch?v=nyko77HpqyM)
[10](https://www.youtube.com/watch?v=IJ3FGb3wn3U)
[11](https://www.angulartraining.com/daily-newsletter/prefetching-with-the-defer-block/)
[12](https://stackoverflow.com/questions/77495876/how-can-i-use-defer-for-lazy-loading-in-angular)
[13](https://stackoverflow.com/questions/78632577/trigger-defer-and-placeholder-blocks-multiple-times)
[14](https://www.youtube.com/watch?v=Tu34Dbe_NrQ)
[15](https://www.angulartraining.com/daily-newsletter/angular-17-trigger-options-for-defer/)
[16](https://www.youtube.com/watch?v=qc4xHvOiLK8)
[17](https://thetechgenics.com/angular/angular-17-deferrable-views/)
[18](https://www.youtube.com/watch?v=7q8OSbqe65E)
[19](https://angular.love/en/how-to-use-angulars-defer-block-to-improve-performance/)
[20](https://www.angularaddicts.com/p/angular-17-feature-deferred-loading-with-signals)
[21](https://timdeschryver.dev/blog/testing-deferrable-views-with-angular-testing-library)