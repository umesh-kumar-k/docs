The core best practice is: **never re-create RxJS streams during a component/service lifetime; instead, define each stream once up-front and model all changes as inputs to that stream.** This yields simpler, more predictable, and less bug-prone reactive code, especially in large Angular codebases.[1]

## Problem Statement & Context
- Large enterprise Angular environment (140+ SPAs, 30+ libs) with many full‑stack devs leads to inconsistent, imperative RxJS usage.[1]
- Very common anti‑pattern: **recreating observables** in response to user actions, route changes, or other events, instead of treating them as single, long‑lived streams.[1]

## TL;DR Best Practice
- “It is ALWAYS possible to fully define a RxJS stream from the start including all sources of change; therefore it is NEVER necessary to re‑create a stream during component/service lifetime.”[1]
- All events that influence a piece of state (clicks, route params, form changes, backend responses) should be modeled as **sources feeding a single pipeline**.[1]

## Simple Example: ProductChooser (Anti‑pattern vs Good Pattern)

### Anti‑pattern: Re‑assigning `product$`
- Component has `product$: Observable<Product>;`.[1]
- `selectProduct(id: number)` directly reassigns stream: `this.product$ = this.productService.loadProduct(id);`.[1]
- Template `product$ | async` resubscribes each time; stream definition changes over time. [1]  

### Good Pattern: Single Stream + Subject
- Introduce `selectedProductId$ = new Subject<number>();`.[1]
- Define `product$` **once**:

  ```ts
  product$ = this.selectedProductId$.pipe(
    switchMap(id => this.productService.loadProduct(id)),
  );
  ```  

- `selectProduct(id)` just does `this.selectedProductId$.next(id);`, or even call `next` from template.[1]
- Benefits:
  - Single, stable `product$` definition; easier to scan and reason about.[1]
  - Natural handling of rapid re‑selection via `switchMap` (cancels previous request).[1]

## Realistic Example: ComplexProductChooser

### Original Implementation (Problems)
- In `ngOnInit`, subscribe to `activatedRoute.params` and inside subscription:
  - Reassign `this.productTypes$ = productService.getTypes(productId);`.[1]
  - Recreate form: `this.productForm = this.buildForm(productId);`.[1]
  - Inside that, subscribe to `this.productForm.get('productType').valueChanges` with `takeUntil(destroy$)` and call `sidebarService.loadAndDisplayContextualProductInfo(productType)`.[1]
- Issues:
  - Every route‑param change **recreates form** and **adds a new subscription** to `productType.valueChanges`.[1]
  - Even with `takeUntil(this.destroy$)`, subscriptions only clean up on component destroy, not when `productId` changes.[1]
  - Leads to multiple concurrent side‑effect streams → performance issues and **out‑of‑sync sidebar data** depending on which async operation finishes last.[1]

### Refactored Implementation (Best Practice)
- Define **all streams once** in `ngOnInit`:

  ```ts
  const productId$ = this.activatedRoute.params.pipe(
    map(params => params.productId),
  );

  this.productTypes$ = productId$.pipe(
    switchMap(id => this.productService.getTypes(id)),
  );

  this.productForm$ = productId$.pipe(
    map(id => this.buildForm(id)),
  );

  this.productForm$.pipe(
    switchMap(form => form.get('productType').valueChanges),
    takeUntil(this.destroy$),
  ).subscribe(type =>
    this.sidebarService.loadAndDisplayContextualProductInfo(type),
  );
  ```  
[1]

- `productForm$` and `productTypes$` are subscribed in the template via `| async`; only **one side‑effect stream** exists for sidebar updates. [1]  
- Now:
  - Route changes flow via `productId$` into both form and types.[1]
  - `switchMap` ensures only the **latest form**’s `productType` changes are honored.[1]
  - Everything that will ever happen is visible declaratively in one place; no reasoning about time or sequence of imperative calls.[1]

## Key RxJS / Angular Types & APIs
- **Subjects**: `Subject<number>` for user selections or events.[1]
- **Operators**:
  - `map` – transform route params to `productId`.[1]
  - `switchMap` – switch to latest inner observable (HTTP calls, `valueChanges`), canceling previous.[1]
  - `takeUntil(this.destroy$)` – lifetime management, but must be applied to **streams defined once**, not repeatedly recreated ones.[1]
- **Angular APIs**:
  - `ActivatedRoute.params` as observable of route changes.[1]
  - Reactive forms: `FormGroup`, `form.get('productType').valueChanges`.[1]

## Design Patterns & Best Practices (from article)

- **Single‑Definition Stream Pattern**:
  - For each conceptual output (e.g., `product$`, `productForm$`, `sidebarEffects$`), define **one observable** that captures all change sources.[1]

- **Separate Sources, Compose with Operators**:
  - Identify sources: route params, user clicks, form changes, backend responses.[1]
  - Model them as observables (`productId$`, `selectedProduct$`, `form$`) and compose them using `map`, `switchMap`, `combineLatest`, etc.[1]

- **Avoid Nested Subscriptions**:
  - Replace nested `.subscribe` chains with composed operators; side effects live in **one terminal subscription** or in effects/services.[1]

- **Avoid RxJS for Purely Sync Logic**:
  - Do not introduce Subjects/streams where logic is fully synchronous and not tied to existing observables; it only adds complexity.[1]

- **Lifecycle & Cleanup**:
  - Use `takeUntil(destroy$)` on **long‑lived, single‑definition** streams; avoid recreating streams inside `subscribe` blocks that themselves use `takeUntil`.[1]

## Advanced Considerations (Architect Level)

- **Predictability & Time‑Independence**:
  - With full stream definition up front, understanding component behavior does **not require replaying sequence of events** in your head; you see all dependencies in one place.[1]

- **Performance & Concurrency Control**:
  - Proper use of `switchMap` on outer change sources (e.g., route, selections) ensures cancellation of outdated work, preventing overlapping HTTP calls or duplicated reactive handlers.[1]

- **Scalability in Enterprise Codebases**:
  - In large teams, this pattern reduces cognitive load and prevents “RxJS monsters” (deeply nested, interdependent subscriptions across the codebase).[1]

## External / “Big Tech” Style References
- Article is based on large‑scale enterprise experience but does not cite specific big‑tech internal docs.[1]
- Broader community (e.g., NgRx and Angular docs) promotes similar reactive patterns: **all state as streams, composed declaratively, no ad‑hoc stream recreation.**

## Interview Cheat Sheet (Q&A)

**Q1: What is the key RxJS best practice from this article?**  
A: Always define RxJS streams completely up front, including all sources of change, and never recreate them during component/service lifetime; model changes as inputs (Subjects, params, valueChanges) to that single stream.[1]

**Q2: Why is recreating streams during component lifetime a problem?**  
A: It leads to multiple concurrent subscriptions, duplicated side effects, performance issues, and inconsistent UI (e.g., sidebar showing stale data depending on which subscription responds last).[1]

**Q3: How does the “ProductChooser” example implement this best practice?**  
A: It introduces `selectedProductId$` and defines `product$ = selectedProductId$.pipe(switchMap(id => loadProduct(id)))` once; button clicks only push IDs into the Subject.[1]

**Q4: How is the complex route + form example improved using this pattern?**  
A: By defining `productId$` from `activatedRoute.params`, then deriving `productTypes$`, `productForm$`, and a single side‑effect stream from `productForm$`+`valueChanges` using `switchMap`, instead of recreating streams and subscriptions on each route change.[1]

**Q5: Why is `switchMap` important in these examples?**  
A: It ensures only the latest request or form instance is active; previous inner observables (HTTP calls or `valueChanges` from older forms) are unsubscribed, avoiding duplicated work and stale side effects.[1]

**Q6: When should you avoid introducing RxJS into logic?**  
A: When logic is fully synchronous and not tied to existing observables; adding streams there only complicates the code without benefits.[1]

**Q7: How does this best practice interact with cleanup patterns like `takeUntil(destroy$)`?**  
A: `takeUntil` is effective when applied to a small number of long‑lived, single‑definition streams; if you keep recreating streams inside `subscribe`, you can still leak behavior or duplicate side effects despite using `takeUntil`.[1]

## Important Terms & Keywords (for quick revision)

- “Never re‑create streams” principle  
- Single stream definition, multiple sources of change  
- `Subject`, `BehaviorSubject` as input sources  
- `switchMap` for latest‑only behavior  
- `map` from route params to IDs  
- `takeUntil(this.destroy$)`  
- `ActivatedRoute.params`  
- Reactive forms: `FormGroup`, `valueChanges`  
- Nested subscriptions (anti‑pattern)  
- Stream re‑creation (anti‑pattern)  
- Declarative RxJS, time‑independent reasoning  
- Side‑effect streams vs UI data streams

[1](https://angularexperts.io/blog/the-most-impactful-rx-js-best-practice-of-all-time)