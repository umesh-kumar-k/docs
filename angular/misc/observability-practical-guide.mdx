Observability for Angular micro frontends here means adding **RUM + logs per micro frontend** using **Datadog** or **Dynatrace**, with small Angular services wrapping each vendor SDK.[1]

***

## Overview & Architecture

- Scenario: Angular micro frontends (Nx example repo) where each micro frontend sends **RUM (Real User Monitoring)** data and **logs** to a central observability platform.[1]
- Tools: **Datadog RUM + browser logs** and **Dynatrace RUM + logs ingest API** as SaaS APM platforms.[1]

Key ideas:
- RUM gives sessions, page views, errors, browser/device info.  
- Log ingestion gives custom app logs (severity, message, origin) correlated with RUM sessions.[1]

***

## Datadog – RUM in Angular Micro Frontend

### RUM setup

- Create Datadog account → UX Monitoring → Sessions Explorer → create **Browser RUM application** (JavaScript type).[1]
- Datadog provides a **RUM snippet** (applicationId, clientToken, site, service, env).  
- Install SDK:  
  `npm install @datadog/browser-rum`.[1]

Typical initialization (in Angular main component or bootstrap module):

- Initialize RUM with:
  - `applicationId`
  - `clientToken`
  - `site` (e.g., `datadoghq.com`)
  - `service` (micro frontend name, e.g., `shell`, `products-mf`)
  - `env` (dev/stage/prod)  
- After init, RUM auto‑captures:
  - Page views, resources, errors, long tasks, user sessions.[1]

Important classes/interfaces (conceptual):
- `datadogRum` (from `@datadog/browser-rum`) – main RUM API: init, addAction, addError.  
- Angular `AppComponent` (or a dedicated ObservabilityBootstrapService) for initializing RUM once per micro frontend.[1]

***

## Datadog – Logs Ingestion from Angular

### Logs setup

- Install logs SDK:  
  `npm install @datadog/browser-logs`.[1]
- Create an Angular `LoggerService` that:
  - Initializes `datadogLogs` with `clientToken`, `service`, `env`.  
  - Exposes methods like `debug`, `info`, `warn`, `error`, mapping to Datadog log levels.[1]

Usage in a micro frontend:
- Inject `LoggerService` and call methods inside HTTP calls, error handlers, and business logic (e.g., Pokédex API demo forced latency and failures).[1]
- Logs appear under **Logs** in Datadog, with filters on service, env, severity.[1]

Pattern: **Encapsulation via Angular service**
- One service per micro frontend:
  - Centralizes Datadog init.
  - Hides vendor SDK behind domain methods (`logHttpError`, `logUxEvent`).[1]

***

## Dynatrace – RUM in Angular Micro Frontend

### RUM setup

- Create Dynatrace SaaS trial → main menu → **Web** → **Set up agentless monitoring**.[1]
- Dynatrace generates a `<script>` snippet to inject in HTML.  
- Add this script to `index.html` of the Angular micro frontend shell or individual MFEs, depending on architecture.[1]

Behavior:
- On app start, Dynatrace RUM captures:
  - Page views, browser types, main errors, and performance metrics exposed in the **Frontend** view.[1]

Key points:
- Agentless RUM uses only HTML script; no Angular‑specific code required for base tracking.[1]
- For micro frontends, ensure **each app has a meaningful application name** / service name to be distinguishable in Dynatrace dashboards.[1]

***

## Dynatrace – Logs Ingestion from Angular

### Logs setup with HTTP client

- Need a Dynatrace **API token** with **“Ingest logs”** scope from “Access tokens”.[1]
- Create `DynatraceLoggerService` in Angular:
  - Inject `HttpClient`.  
  - Define `url = 'https://<envId>.live.dynatrace.com/api/v2/logs/ingest'`.[1]
  - `logger(type, message, source)` builds an object like:
    - `severity`: log type (INFO/WARN/ERROR).  
    - `content`: message.  
    - `log.source`: origin (e.g., micro frontend name).[1]
  - Set headers:
    - `Content-Type: application/json; charset=utf-8`  
    - `Authorization: Api-Token <Generated Token>`.[1]
  - `ingestLog()` does `http.post(url, body, { headers })`.[1]

Result:
- Logs show up in **Logs and Events** in Dynatrace with filtering by severity and custom fields.[1]

Pattern: **Manual log ingestion over HTTP**
- More boilerplate than Datadog browser logs but very flexible in shaping log payloads and adding custom attributes.[1]

***

## Design Patterns Highlighted

- **Per‑tool Observability Service**:
  - `DatadogLoggerService`, `DynatraceLoggerService`:
    - Wrap vendor SDK or HTTP API.
    - Provide narrow methods: `logInfo`, `logError`, `logPerformanceIssue`.
    - Inject via DI across micro frontends.[1]

- **Per‑micro‑frontend service naming**:
  - Each MFE identifies itself with a `service`/`application` name in RUM/logs.
  - Enables filtering, dashboards, and SLOs per micro frontend.[1]

- **Shared log schema**:
  - For Dynatrace logs: `severity`, `content`, `log.source`.
  - You can extend with enums/interfaces so each frontend uses the same schema for incident correlation.[1]

***

## Best Practices (Senior Architect Angle)

- Initialize observability **at micro frontend boundary**:
  - RUM init in shell or each MFE depending on whether you want a single session vs multiple per MFE.  
- Use **consistent service names**: `mfe-cart`, `mfe-product`, `shell` to make dashboards meaningful.[1]
- Avoid leaking sensitive data into logs/RUM events (no PII in `content`).  
- Use Angular services for observability; do not scatter direct SDK calls across components.  
- Align backend and frontend names for services/endpoints to simplify correlation across Datadog/Dynatrace APM and RUM.[2][3][1]

Trade‑offs observed in the article:
- Datadog:
  - Easier implementation, more intuitive UI for infra+logs.[1]
- Dynatrace:
  - More effort to set up logs, but more flexible/customizable dashboards.[1]

***

## Advanced Topics / Big‑Tech‑Style Practices

- **Full‑stack correlation**:
  - Use the same `service` and `env` names between frontend RUM and backend APM services in Datadog/Dynatrace for cross‑view traceability.[4][2]
- **Micro frontend ownership**:
  - Per‑team dashboards per micro frontend with errors rate, Apdex, and core Web Vitals.[3][2]
- **Feature‑level logging**:
  - Log at domain boundaries (checkout, authentication, search) rather than at low‑level technical details only.  
- **SaaS cost & sampling**:
  - Use log sampling and log levels to control volume from many MFEs.

Datadog & Dynatrace both publish frontend monitoring best‑practices emphasizing:
- Clear service naming.
- Separation of environments.
- Use of RUM + logs + APM together.[2][3][4]

***

## Interview Cheat Sheet (Q&A)

**Q1: What are the main observability pillars implemented in this Angular micro‑frontend POC?**  
A: Real User Monitoring (RUM) for user sessions and performance, and log ingestion for application‑level events, implemented with both Datadog and Dynatrace.[1]

**Q2: How is Datadog RUM integrated into an Angular micro frontend?**  
A: Create a Datadog RUM application, install `@datadog/browser-rum`, and initialize the RUM snippet (applicationId, clientToken, service, env) in the main Angular component or a bootstrap service, after which RUM auto‑captures user sessions and events.[1]

**Q3: How are logs from an Angular micro frontend sent to Datadog?**  
A: Install `@datadog/browser-logs`, create an Angular logging service that initializes `datadogLogs` with clientToken and RUM application name, and expose methods per log level that send logs to Datadog’s Logs UI.[1]

**Q4: How does Dynatrace RUM differ in integration approach?**  
A: Dynatrace generates an agentless RUM script that is injected into the main `index.html`, with no Angular‑specific code required for basic monitoring.[1]

**Q5: How are logs ingested into Dynatrace from Angular?**  
A: Use an `HttpClient`‑based `DynatraceLoggerService` that posts log entries to the `api/v2/logs/ingest` endpoint using an API token with “Ingest logs” scope, sending fields like severity, content, and log.source.[1]

**Q6: What architectural patterns are used for observability in micro frontends?**  
A: Vendor‑specific Angular services (per tool), consistent service naming across micro frontends, and a shared log schema to normalize observability data across Datadog and Dynatrace.[1]

**Q7: Why did the author say Datadog felt more efficient than Dynatrace for logs?**  
A: Datadog’s browser logs SDK and UI make log ingestion more intuitive and quicker to implement compared to the more manual HTTP setup needed for Dynatrace logs, though Dynatrace offers more flexible dashboard customization.[1]

***

## Important Terms & Keywords (for quick skim)

1. **RUM (Real User Monitoring)** – session/page/error tracking in the browser.[1]
2. **Datadog RUM** – `@datadog/browser-rum`, Sessions Explorer.[2][1]
3. **Datadog browser logs** – `@datadog/browser-logs`, log levels (debug/info/warn/error).[1]
4. **Dynatrace agentless RUM** – script snippet in `index.html`.[1]
5. **Dynatrace logs ingest API** – `api/v2/logs/ingest`, `Api-Token` header, `severity`, `content`, `log.source`.[1]
6. **Micro frontend (µFrontend)** – per‑MFE service naming (e.g., `mfe-cart`, `mfe-shell`).[1]
7. **LoggerService / DynatraceLoggerService** – Angular injectable wrappers over vendor SDK or HTTP APIs.[1]
8. **Service name / env** – key tags for dashboards and filters across MFEs.[2][1]
9. **Sessions Explorer (Datadog)** – view user sessions and events.  
10. **Logs & Events (Dynatrace)** – view ingested logs.  
11. **Nx micro frontend example** – GitHub Nx example repo used as POC base.[1]
12. **SaaS APM** – Datadog and Dynatrace as hosted monitoring platforms.[1]

[1](https://signoz.io/blog/opentelemetry-angular/)
[2](https://www.datadoghq.com/monitoring/angular-performance-monitoring/)
[3](https://www.datadoghq.com/blog/modern-frontend-monitoring/)
[4](https://www.fabianstadler.com/2023/01/enhancing-microservice-observability.html)