This 2‑part series argues that **tokens don’t belong in the browser** and recommends **server‑side OAuth2/OIDC via an Authentication Gateway (a specialized reverse proxy)**. Tokens stay on the gateway; the SPA only sees an HTTP‑only session cookie plus an XSRF token.[1][2]

***

## Part 1 – Problems with Tokens in the Browser[1]

### Implicit Flow & Code Flow for SPAs
- Historically SPAs used **Implicit Flow**: tokens returned in URL fragment, then read by SPA.[1]
- Problems:
  - Tokens leak into browser history/logs/proxies.
  - Requires multiple mitigations (history overwrite, logging config).[1]
- Best‑practice docs (OAuth 2.0 Security BCP, OAuth 2.0 for Browser-Based Apps) now **forbid implicit flow**; recommend **Authorization Code Flow + PKCE** even for SPAs.[1]

### Token Storage & XSS
- Browser cannot securely store tokens; **XSS** (injection) in OWASP Top 10 shows real risk.[1]
- Best practice: **short‑lived access tokens** (≈10 minutes), but then SPAs need **automatic refresh** without user interaction.[1]

### Token Refresh Issues
- **Silent refresh in hidden iframe**:
  - Uses auth server cookie to silently re‑authenticate.
  - Standards‑compliant but hacky: relies on iframes, breaks **SameSite** cookies (weakened XSRF defense).[1]
- **Refresh tokens in the browser**:
  - Originally **forbidden**; newer best practices allow only with strict **risk assessment** and constraints:
    - Rotation (new refresh token each use).
    - Max lifetime + idle timeout.
    - Revoke if multiple clients use same refresh token (possible attacker).[1]
- Net conclusion: **Browser is not safe for tokens**, and refresh is hard to do correctly.[1]

***

## Part 2 – Solution: Authentication Gateways (Server‑Side OAuth2)[2]

### Concept & Benefits
- **Authentication Gateway** (aka forward auth / BFF‑style gateway):
  - Reverse proxy in front of SPA + APIs.
  - Handles OAuth2/OIDC **server‑side**:
    - Obtains, stores, and refreshes tokens in **server session**.
    - Forwards tokens to APIs; SPA never sees them.[2]
  - SPA only gets an **HTTP‑only** session cookie (plus XSRF token).[2]
- Advantages:
  - No tokens in browser → XSS cannot steal them via JS.[2]
  - OAuth2/OIDC logic removed from SPA and APIs; both simplified.[2]
  - Supports existing IdPs (Azure AD, Auth0, Keycloak, IdentityServer, etc.).[2]

### XSRF Protection: SameSite + XSRF Tokens
- Gateway session cookie: **HTTP‑only + SameSite**.[2]
- But SameSite = same “site” across subdomains, so cross‑subdomain XSRF still possible.[2]
- Solution: **XSRF token** issued by gateway:
  - SPA sends XSRF token with each call.
  - Gateway verifies token belongs to logged‑in user.[2]
- Angular `HttpClient` does this automatically:
  - If cookie named `XSRF-TOKEN` present, Angular sends `X-XSRF-TOKEN` header for each API call (names configurable).[2]

### Gateway Implementation (YARP + OIDC middleware)
- Uses **YARP** (Yet Another Reverse Proxy) + ASP.NET Core + OIDC middleware.[2]
- Runs in Docker; config in `appsettings.json`, not Angular-specific.[2]

**Routing config (ReverseProxy section)**:
```jsonc
"ReverseProxy": {
  "routes": {
    "apiRoute": {
      "ClusterId": "apiCluster",
      "AuthorizationPolicy": "authPolicy",
      "Match": { "Path": "api/{**remainder}" }
    },
    "appRoute": {
      "ClusterId": "appCluster",
      "AuthorizationPolicy": "authPolicy",
      "Match": { "Path": "{**remainder}" }
    }
  },
  "clusters": {
    "apiCluster": {
      "destinations": { "destination1": { "Address": "http://demo.angulararchitects.io" } }
    },
    "appCluster": {
      "destinations": { "destination1": { "Address": "http://localhost:4200" } }
    }
  }
}
```

- `apiRoute`: `/api/**` → API; adds access token (refreshes if needed).[2]
- `appRoute`: all other paths → SPA.[2]

**Gateway & OIDC config**:
```jsonc
"Gateway": {
  "SessionTimeoutInMin": "60",
  "Url": "http://localhost:8080"
},
"Apis": [
  { "ApiPath": "/flight-api/" },
  { "ApiPath": "/passenger-api/" }
],
"OpenIdConnect": {
  "Authority": "https://login.microsoftonline.com/.../v2.0",
  "ClientId": "90c82e3f-...",
  "ClientSecret": "fj67Q...",
  "Scopes": "openid profile email offline_access api://flight-api/read-write",
  "QueryUserInfoEndpoint": false
}
```

- `SessionTimeoutInMin`: token/session lifetime.[2]
- `Apis`: paths where gateway forwards API calls with access token.[2]
- `OpenIdConnect`:
  - `Authority`: IdP base URL (Azure AD / Keycloak / Auth0 / IdentityServer).[2]
  - `Scopes`: `openid profile email offline_access` (+ API-specific scopes).[2]

### SPA Code with Gateway

- SPA doesn’t handle OAuth flows or tokens; just uses gateway endpoints:

```ts
@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  loadUserInfo(): Observable<unknown> {
    return this.http.get<unknown>('/userinfo');
  }

  login(): void  { location.href = '/login'; }
  logout(): void { location.href = '/logout'; }
}
```

- `/userinfo`: gateway endpoint returning logged‑in user info.[2]
- `/login` / `/logout`: gateway endpoints that trigger OIDC login/logout with redirects; SPA only redirects browser.[2]

### Security Trade‑offs
- XSS still a concern:
  - Attacker can issue requests from user’s browser (browser sends cookie).[2]
  - But cannot extract cookie (HTTP‑only), and attack ends when browser closed.[2]
- Compare to SPA-managed tokens:
  - Attacker can steal long‑lived refresh token/access token and use from their own machine, even after user closes browser.[1][2]

***

## Design Patterns & Best Practices

- **Avoid storing tokens in SPAs**; prefer **server‑side token handling** via gateway.[1][2]
- For SPAs that must handle tokens:
  - Use **Authorization Code + PKCE**, **short‑lived access tokens**, and carefully controlled refresh tokens (rotated, expiring).[1]
- Use **Authentication Gateway**:
  - Reverse proxy (YARP / NGINX / Kong / Traefik / OAuth2 Proxy / IdentityServer BFF) handling OAuth2/OIDC.[2]
  - SPA only deals with `login/logout/userinfo`.[2]
- Always enable:
  - **HTTP‑only + SameSite cookies**.
  - **XSRF tokens** + Angular’s built‑in XSRF header support.[2]
- Accept extra **ops complexity** (managing gateway) in exchange for **simpler, safer SPAs**.[2]

***

## Interview Cheat Sheet (Q&A)

**Q1: Why are tokens in the browser problematic for Angular SPAs?**  
A: Browsers can’t securely store tokens; XSS can steal them. Implicit flow leaks tokens via URLs/history; refresh handling (iframe or refresh tokens) is complex and error‑prone, so OAuth 2.0 best practices recommend server‑side token handling instead.[1]

**Q2: What does OAuth 2.0 now recommend for browser-based apps?**  
A: Use **Authorization Code Flow with PKCE** (no implicit flow), short‑lived access tokens, and extremely careful use of refresh tokens (rotation, expiry, risk assessment).[1]

**Q3: What is an Authentication Gateway in this context?**  
A: A reverse proxy that terminates OAuth2/OIDC, stores tokens server‑side, forwards access tokens to APIs, and exposes only an HTTP‑only session cookie + simple endpoints (`/login`, `/logout`, `/userinfo`) to the SPA.[2]

**Q4: How does Angular automatically support XSRF with such a gateway?**  
A: When Angular `HttpClient` sees a cookie named `XSRF-TOKEN`, it automatically sends it in an `X-XSRF-TOKEN` header to the backend, which the gateway can validate to ensure the request originates from the logged‑in user.[2]

**Q5: How is the gateway configured to route SPA and API traffic?**  
A: Using a reverse proxy (e.g., YARP) with two routes: `/api/**` → API cluster (with attached access token) and `/**` → SPA cluster; plus OIDC settings (`Authority`, `ClientId`, `Scopes`) for token acquisition.[2]

**Q6: How does SPA code change with a gateway compared to direct OAuth integration?**  
A: SPA no longer manages tokens or flows; it just calls `/userinfo` for user data and redirects to `/login` or `/logout` endpoints of the gateway.[2]

**Q7: Does an Authentication Gateway remove the need to worry about XSS?**  
A: No; XSS can still issue requests with the user’s cookie, but cannot steal the cookie or tokens. Attacks end when the browser session ends, unlike client‑side token theft where the attacker can act long after.[1][2]

***

## Key Terms & Keywords

- OAuth2, OpenID Connect (OIDC)
- **Implicit Flow** (deprecated for SPAs)
- **Authorization Code Flow + PKCE**
- Access Token, ID Token, Refresh Token, Token Rotation
- XSS (Cross‑Site Scripting), XSRF/CSRF
- **SameSite cookies**, HTTP‑only cookies
- **Authentication Gateway**, Forward Authentication, BFF (in this context)
- Reverse proxy: **YARP**, Kong, Traefik, OAuth2 Proxy, IdentityServer BFF
- `XSRF-TOKEN` cookie, `X-XSRF-TOKEN` header (Angular HttpClient)
- `/login`, `/logout`, `/userinfo` gateway endpoints
- `Authority`, `ClientId`, `ClientSecret`, `Scopes` in OIDC config[1][2]

[1](https://angular.dev/guide/testing/component-harnesses-overview)
[2](https://www.angulararchitects.io/blog/micro-frontends-with-modern-angular-part-1-standalone-and-esbuild/)