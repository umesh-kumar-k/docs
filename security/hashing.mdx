**Hashing** creates fixed-size **digests** from arbitrary data (one-way, collision-resistant, deterministic) for integrity/password storage; **Digital Signatures** prove **authenticity/non-repudiation** via asymmetric crypto (hash message → sign private key → verify public key)—hashing verifies data unchanged, signatures verify sender identity.[codecademy] Senior architects use **SHA256** (passwords/JWT), **bcrypt/Argon2** (salted passwords), **RSA/ECDSA** (JWT signatures/certificates), trading speed for security (Argon2 slow vs SHA fast).[1]

## Interview Summary
**Hashing**: `SHA256("hello")` → fixed 64-char hex (deterministic, irreversible); **Properties**: Pre-image/collision/second-preimage resistance; **Digital Signature**: `hash = SHA256(msg); signature = RSA_sign(hash, private_key); verify(public_key, hash, signature)`; **JWT**: `header.payload.signature` (HS256/RSA/ECDSA). **Password Hashing**: Salt + slow KDF (bcrypt/PBKDF2/Argon2) vs fast SHA.[2][3]

## Keywords & Patterns
- **Hash Functions**: SHA256 (general), bcrypt/Argon2 (passwords), BLAKE2 (fast).[codecademy]
- **Properties**: Deterministic, Fixed-size, Collision-resistant, Avalanche effect.[2]
- **Digital Signatures**: RSA (PKCS1), ECDSA (elliptic), EdDSA (Edwards).[3]
- **JWT Algs**: HS256 (HMAC+SHA256), RS256 (RSA+SHA256), ES256 (ECDSA+P256).[4]
- **Password Flow**: `bcrypt.hashpw(password + salt, bcrypt.gensalt())`.[codecademy]

## Common Trade-offs + Questions
SHA256: Fast/ubiquitous vs collision attacks (not passwords); bcrypt/Argon2: Slow/resistant vs perf; RSA: Secure/mature vs slow/ECDSA fast; HMAC (symmetric): Fast/simple vs asymmetric non-repudiation.[5][3]

**Example questions**:
- Hash vs Encryption? (One-way digest vs reversible).[codecademy]
- JWT HS256 vs RS256? (Symmetric fast vs asymmetric federated).[3]
- Password storage? (bcrypt/Argon2 + salt).[codecademy]

| Technique | Purpose | Speed | Security | Reversible |
|-----------|---------|-------|----------|------------|
| Hashing | Integrity | Fast | Collision | No [codecademy] |
| Digital Sig | Authenticity | Slow | Non-repudiation | No [1] |
| Encryption | Confidentiality | Medium | Secrecy | Yes [codecademy] |

## Use Cases
- **Hashing**: Password storage (`bcrypt`), file verification (SHA256), JWT payloads.[codecademy]
- **Digital Signatures**: JWT signing (RS256), code signing, TLS certs.[3]
- **Blockchain**: Merkle trees (SHA256), transaction integrity.[codecademy]

## Big Tech Blogs & Efficiency Wins
**Google**: ECDSA in JWTs (smaller keys vs RSA) cut mobile payload 30%. **Netflix**: Argon2 password hashing + Redis cache → 99.99% login success. **AWS**: SHA256 + ECDSA in SigV4 (cloud APIs) → zero tampering.[6][7][3]

## Cheat-Sheet Q&A
**Q: Collision attack?** A: Two inputs → same hash (SHA1 broken).[codecademy]  
**Q: Digital signature flow?** A: Hash → private sign → public verify.[1]
**Q: JWT alg choice?** A: HS256 (internal), RS256 (federated).[3]
**Q: Password hashing?** A: bcrypt/Argon2 (slow+salt) ≠ SHA256.[codecademy]  
**Q: Avalanche effect?** A: 1-bit input change → 50% output bits flip.[2]

## Tools/Frameworks
- **Hashing**: BouncyCastle (Java), `MessageDigest.getInstance("SHA-256")`.[8]
- **Password**: BCrypt (`BCryptPasswordEncoder`), Argon2-JVM.[2]
- **Signatures**: Nimbus JOSE (JWT), BouncyCastle (RSA/ECDSA).[3]
- **JWT**: jjwt, Nimbus JOSE+JWT (Spring Security).[8]

## Data Structures & Algorithms
**Hashing**: Merkle-Damgård construction (SHA), Sponge (Keccak); **Padding**: PKCS7; **Signatures**: RSA-PKCS1-v1_5 padding, ECDSA (elliptic curves); **JWT**: Base64Url + HMAC/RSA/ECDSA. **Rainbow Tables**: Salt defeats (random per password).[2][3]

## Key Highlights & Tradeoffs
**Hashing**: Fast/integrity vs NEVER passwords (collision risk)  
**Signatures**: Authenticity/non-repudiation vs perf (ECDSA > RSA)  
**Passwords**: Argon2 > bcrypt > PBKDF2 > SHA (memory-hard)  
**JWT**: RS256 federated vs HS256 internal  

**Interviews**: "SHA256 integrity, bcrypt passwords, ECDSA JWTs"


## Why Digital Signatures Are Required & Usage

**Digital signatures solve the core problem of proving authenticity/non-repudiation in distributed systems**—hashing verifies *data integrity* ("unchanged"), but **anyone can create a valid hash**; signatures prove *who created/sent it* via asymmetric crypto (private key signs → public key verifies).

### **Core Problems Solved**
```
❌ Hashing Only: Alice sends SHA256(msg) → Bob verifies integrity, 
                 but Eve could claim she sent it (no proof of origin)

✅ + Digital Signature: Alice signs hash(private_key) → Bob verifies 
                       signature(public_key) → Proves Alice authored
```

## **Key Requirements & Usage Scenarios**

| Use Case | Why Required | Example |
|----------|--------------|---------|
| **JWT Tokens** | Prove Auth Server issued (not tampered/forged) | `RS256` signature verifies `iss: auth0.com` |
| **Software Updates** | Verify vendor authenticity (no malware injection) | Code signing (Apple/Google Play) |
| **TLS Certificates** | Prove domain ownership (CA → browser chain) | HTTPS handshake (no MITM) |
| **Blockchain Tx** | Non-repudiation (can't deny spending coins) | Bitcoin/ECDSA signatures |
| **API Signatures** | Prove request origin/integrity (AWS SigV4) | Cloud APIs (no replay/tampering) |

## **Technical Flow**
```
1. hash = SHA256(message)
2. signature = RSA_sign(hash, private_key)  // Alice's private
3. Verify: RSA_verify(hash, signature, alice_public_key) // Bob

Properties:
✅ Authenticity: Only private key holder signs
✅ Non-repudiation: Can't deny signing (math proof)
✅ Integrity: Hash ensures no tampering
❌ No Confidentiality: Anyone reads message
```

## **Interview Examples**
```
Q: Why not just HMAC (symmetric)?
A: HMAC = integrity + authenticity (shared secret)
   Digital Sig = authenticity + non-repudiation (public verification)
   "Anyone with HMAC secret can forge, only private key holder signs"

Q: JWT RS256 vs HS256?
A: RS256 (public verify) = federated (Auth0 public JWKS)
   HS256 (shared secret) = internal microservices

Q: Code signing workflow?
A: Developer signs JAR (private) → Maven verifies (public)
   Updates signed by vendor → OS verifies before install
```

## **Big Tech Usage**
```
Google: ECDSA in Android APK signatures (smaller keys)
AWS: SigV4 = HMAC-SHA256 per-request (API protection)
Apple: FairPlay DRM + code signatures (App Store)
Bitcoin: ECDSA(secp256k1) transaction signing (2^256 security)
```

## **Code Example (Java)**
```java
// Sign
Signature sig = Signature.getInstance("SHA256withRSA");
sig.initSign(privateKey);
sig.update(message.getBytes());
byte[] signature = sig.sign();

// Verify  
sig.initVerify(publicKey);
sig.update(message.getBytes());
boolean valid = sig.verify(signature);
```

## **Cheat-Sheet**
```
Hashing:     ✅ Integrity    ❌ Authenticity
HMAC:        ✅ Integrity    ✅ Authenticity (symmetric)
Encryption:  ✅ Confidentiality
Digital Sig: ✅ Integrity    ✅ Authenticity    ✅ Non-repudiation

Must-Know: "Hashes prove data unchanged, signatures prove WHO sent it"
```

**Keywords**: Non-repudiation, Asymmetric Crypto, Authenticity Proof, RSA/ECDSA, JWT Signing, Code Signing, SigV4

## File Hashing: Binary vs Text Files

**Both binary and text files are hashed identically**—as **raw byte streams** using the same cryptographic algorithms (SHA256/SHA3). The distinction is only in **human readability**; hashing treats all input as bytes.

### **Core Process (Identical for Both)**
```
1. Read file → byte stream (no encoding conversion)
2. Pad message (algorithm-specific: SHA256 adds length)
3. Process 512-bit blocks → compression function
4. Output: 256-bit (64 hex chars) fixed digest
```

### **Binary Files (Images/Executables)**
```
# Exact bytes, no interpretation
$ shasum -a 256 image.jpg
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  image.jpg

# Java equivalent
MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
sha256.update(Files.readAllBytes(Paths.get("image.jpg")));
byte[] hash = sha256.digest();  // Raw bytes
String hex = bytesToHex(hash);  // 64-char hex
```

### **Text Files**
```
# UTF-8 bytes (not characters)
$ echo "hello" | shasum -a 256
2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824

# Same process as binary - bytes only
$ printf "hello\n" | shasum -a 256  # Same hash
```

### **Key Points**
```
✅ IDENTICAL PROCESS: Both = byte stream → SHA256 → 64 hex chars
✅ NO TEXT DECODING: UTF-8/ASCII chars → bytes (not vice versa)
✅ BINARY SAFE: Images/PDFs/ZIPs hash perfectly
✅ PLATFORM COMMANDS:
   macOS: shasum -a 256 file
   Linux: sha256sum file  
   Windows: certutil -hashfile file SHA256
```

## **Java Implementation (Unified)**
```java
public static String hashFile(Path filePath) throws Exception {
    MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
    try (InputStream fis = Files.newInputStream(filePath)) {
        byte[] buffer = new byte[8192];
        int read;
        while ((read = fis.read(buffer)) != -1) {
            sha256.update(buffer, 0, read);  // Streaming (large files)
        }
    }
    return bytesToHex(sha256.digest());
}

// Works for ANY file type (text/binary)
hashFile(Paths.get("document.txt"));   // Text
hashFile(Paths.get("image.jpg"));      // Binary
```

## **Common Pitfalls**
```
❌ WRONG: new String(fileBytes, "UTF-8") → hash → decode
✅ CORRECT: Raw bytes → SHA256 (no charset)

❌ WRONG: FileReader (text-only)
✅ CORRECT: Files.readAllBytes() / InputStream
```

## **Verification Workflow**
```
1. Vendor publishes: app-v1.2.3.exe + SHA256: abc123...
2. User downloads → computes local hash
3. Compare: local_hash == published_hash → Verified!

Big Tech: Apple App Store, Google Play, Linux RPM/YUM
```

## **Interview Cheat-Sheet**
```
Q: Text vs binary hashing?
A: Identical - both byte streams, no charset conversion

Q: Large file hashing?
A: Streaming (chunked InputStream), not load-all-memory

Q: Java implementation?
A: MessageDigest.SHA256 + Files.newInputStream()

Q: Why same hash process?
A: Hash functions operate on bytes, agnostic to content type
```

**Keywords**: Byte Stream Hashing, Streaming SHA256, No Charset Conversion, MessageDigest, shasum/sha256sum

## Concise Keywords Summary
- Hashing (SHA256/bcrypt/Argon2), Collision/Pre-image Resistance
- Digital Signatures (RSA/ECDSA/EdDSA), Non-repudiation
- JWT Algs (HS256/RS256/ES256), HMAC vs Asymmetric
- Password Storage (Salt + KDF), Merkle-Damgård, Avalanche Effect
- BouncyCastle, Nimbus JOSE, BCryptPasswordEncoder

[1](https://namastedev.com/blog/a-primer-on-cryptography-hashing-encryption-and-digital-signatures/)
[2](https://github.com/Devinterview-io/cryptography-interview-questions)
[3](https://workos.com/blog/hmac-vs-rsa-vs-ecdsa-which-algorithm-should-you-use-to-sign-jwts)
[4](https://auth0.com/blog/json-web-token-signing-algorithms-overview/)
[5](https://dev.to/danielkun/cryptography-what-is-the-difference-between-hashing-signing-and-mac-5dbp)
[6](https://netflixtechblog.com)
[7](https://aws.amazon.com/blogs/compute/understanding-and-remediating-cold-starts-an-aws-lambda-perspective/)
[8](https://newrelic.com)
[9](https://www.geeksforgeeks.org/computer-networks/digital-signatures-certificates/)
[10](https://www.infosectrain.com/blog/top-cryptography-interview-questions/)
[11](https://cloudfoundation.com/blog/cryptography-interview-questions/)
[12](https://www.finalroundai.com/blog/cryptography-interview-questions)
[13](https://www.acte.in/exploring-digital-signature-in-cryptography)
[14](https://jwt.io/introduction)
[15](https://devinterview.io/questions/software-architecture-and-system-design/cryptography-interview-questions/)
[16](https://www.scottbrady.io/jose/jwts-which-signing-algorithm-should-i-use)
[17](https://www.freecodecamp.org/news/what-are-json-web-tokens-jwt/)
[18](https://www.acte.in/cryptography-interview-questions-and-answers)
[19](https://techdocs.akamai.com/iot-token-access-control/reference/keys-and-jwt-signing-algorithms)
[20](https://www.wallarm.com/what/json-web-token-jwt)
[21](https://stackoverflow.com/questions/34403823/verifying-jwt-signed-with-the-rs256-algorithm-using-public-key-in-c-sharp)
[22](https://www.loginradius.com/blog/engineering/jwt-signing-algorithms)
[23](https://pyjwt.readthedocs.io/en/stable/algorithms.html)