Nx’s Module Federation support gives you first-class, generator-driven microfrontend scaffolding (hosts, remotes, shared libs) plus static/dynamic federation and SSR, all integrated with Nx graphs, caching, and deployment workflows.[1][2]

***

## Page 1: NxModuleFederationPlugin (Introduction)

### Key topics
- Rspack-based Module Federation integration.
- Alignment with `withModuleFederation` DX.
- Base config + runtime + shared libs.[1]

### Core ideas
- `NxModuleFederationPlugin` is an Rspack plugin that configures Module Federation in Nx workspaces, mirroring Nx’s `withModuleFederation` helper.[1]
- Added in `rspack.config.ts` and used for both CSR and SSR setups.[1]

### How it works (details)
- **Base configuration**:[1]
  - Disables runtime chunking (`runtimeChunk: false`).  
  - Sets a unique output name.  
  - Applies SSR-specific flags when in server mode.
- **Module Federation wiring**:[1]
  - Configures `remoteEntry.js`.  
  - Registers exposed modules and remote connections.  
  - Handles shared dependencies/libraries (version consistency, de-dup).  
- **Runtime plugins**: special handling for Node.js when in server mode.[1]

### Best practices / trade-offs
- Use `NxModuleFederationPlugin` rather than hand-writing Rspack MF config: consistent DX, fewer footguns (runtime chunking, shared libs rules).[1]
- Trade-off: you’re opinionated into Nx’s MF conventions; fully custom MF behavior may require dropping down to raw `@module-federation/enhanced`.[1]

***

## Page 2: Create a Host (Serving your Host)

### Concepts: Host & federation modes
- **Host**: app that loads/consumes federated modules from remotes; remotes fetched over network at runtime.[2]
- Static vs Dynamic Federation:  
  - Static: host knows remote URLs at build time.  
  - Dynamic: host discovers remote locations at runtime (e.g., via manifest).[2]

### Generating a host
- Command to generate **only** a host app (React/Angular) in workspace.[2]
- Command to scaffold host **plus** remotes in one shot (host + X remotes wired together).[2]

### Serving your host
- Serve like any Nx app: `nx serve <host>`.[2]
- Nx automatically discovers dependent remotes in the workspace and serves them statically when host runs, so MF dev environment is one command.[2]

### Building your host
- `nx build <host>` builds host only by default; no `implicitDependencies` to remotes → supports independent deployability.[2]
- To force building remotes with host, explicitly add them as `implicitDependencies` in host’s `project.json`.[2]

### Best practices / trade-offs
- Keep host free of `implicitDependencies` if you want fully independent remote deploy pipelines.[2]
- Add `implicitDependencies` only for environments where “host + all remotes” must be version-locked (e.g., preview/staging).[2]

***

## Page 3: Create a Remote (Generating a Remote)

### Core concepts
- **Remote**: exposes modules for consumption by a host.   
- Difference:  
  - Remote: producer (exposes).  
  - Host: consumer (loads). 

### Generating a remote
- Generator creates remote app; you then update host’s MF config to consume it.   
- Or pass `--host=<hostName>` so Nx auto-adds the remote to host config (wires MF config for you). 

### Building & serving remotes
- `nx build <remote>` builds remote like any app.   
- Two serve targets:   
  - `serve`: uses `webpack-dev-server` → HMR + live reload, full dev UX.  
  - `serve-static`: builds then serves with `http-server` (static assets, lower CPU/RAM, no HMR).

### Serving remote via host
- When you `nx serve <host>`, Nx:   
  - Builds or pulls from cache the dependent remotes.  
  - Serves them all through a single static file server (optimized dev footprint).  
- You can override for active development on a specific remote: run host such that certain remotes use `serve` (HMR) and others use `serve-static`. 

### Best practices / trade-offs
- Use `serve-static` for background remotes to minimize dev machine load; use `serve` only for current focus remote.   
- Trade-off: HMR vs resource consumption; tune per-team/per-remote. 

***

## Page 4: Federate a Module

### Federated module concept
- Module Federation = share code at runtime (microfrontends or generic shared code).   
- A “module” can be any independently useful unit: component, service, library, utility, etc.   
- To be shareable, module must be **federated**: remote config exposes it; host config consumes it. 

### Step 1 – Create module (lib)
- Create an Nx library (e.g., `greeting`) and implement your reusable functionality (e.g., `hello.ts` exporting a function).   
- Update barrel (`index.ts`) to re-export the module. 

### Step 2 – Federate the module
- Run Nx federation command against the module/lib:   
  - Adds entry to remote’s `module-federation.config.ts` (e.g., `greeting/Hello`).  
  - Adds TS path mapping in root `tsconfig` for typed imports. 

### Step 3 – Use from host
- In host, import and use federated module just like a local TS import (Angular/React example code). 

### Step 4 – Run the system
- Run host app, e.g. `http://localhost:4200`; remote (e.g., `greeting` on 4201) provides content like “Hello from Nx”.   

### Best practices
- Treat federated modules as clear, cohesive units; keep contracts stable to avoid breaking hosts.   
- Use Nx library boundaries and MF only where cross-app runtime sharing is actually needed; keep most reuse as standard shared libs to limit runtime coupling. 

***

## Page 5: NxModuleFederationPlugin Guide (Deployment)

### Usage (restate, Rspack angle)
- Add `NxModuleFederationPlugin` to `rspack.config.ts`; configure CSR/SSR modes similarly to Webpack `withModuleFederation`.[1]

### Deployment strategies
- **À la carte deployments**: each app (host/remote) has its own cadence; MF just needs correct URLs.[1]
- **Affected deployments**: use Nx “affected” to auto-test/deploy only changed hosts/remotes on merge.[1]
- Mixed model: auto-deploy to staging, promote to prod on cadence.[1]

### Core-libs considerations
- Shared core libraries across hosts/remotes can block releases; avoid frequent breaking changes or coordinate releases.[1]

### MF URL resolution (local vs prod)
- Locally: Nx parses `module-federation.config.ts`, uses project graph & ports to derive URLs like `http://localhost:4201/remoteEntry.js`.[1]
- In prod: you must configure real URLs (domains, paths) in `remotes` config.[1]
- Use env-based switching, e.g., `PRODUCTION_DEPLOY` to toggle between local auto-URLs and production MF URLs.[1]

### Best practices / trade-offs
- For big-org MFE: consider “affected + remote cache + partial deploys” plus strong e2e tests and rollback.[1]
- Trade-off: independent deployability vs central coordination of shared libs and breaking changes.[1]

***

## Page 6: Dynamic Module Federation with Angular

### Concept: “Build once, deploy everywhere”
- Dynamic MF lets host discover remote URLs at **runtime**, not build time.   
- Solves: different remote URLs per environment without rebuilding host each time. 

### Aim
- Set up static MF.  
- Convert static to dynamic.  
- Generate new dynamic MF apps via generators. 

### What we build
- Base architecture:   
  - `Dashboard` (host).  
  - `Login` (remote).  
  - Additional `Employee Dashboard` host using dynamic federation.  
  - `Todo` remote, plus reuse existing `Login`.  

### First steps & generation
- Create Nx workspace + add `@nx/angular`.   
- Generate `Dashboard` as MF host via Nx host generator.   
- Generate `Login` as MF remote with `--host=dashboard`:   
  - Adds remote to `apps/dashboard/module-federation.config.ts`.  
  - Adds TS path mapping to root `tsconfig`.  
  - Adds route to `apps/dashboard/src/app/app.routes.ts`.

### Generated structure
- Both apps get:   
  - Standard Angular app files.  
  - `module-federation.config.ts`.  
  - `webpack.config.ts` and `webpack.prod.config.ts`.  
  - `src/bootstrap.ts`, with `main.ts` changed to dynamically import `bootstrap.ts` (for MF shared libs correctness).  
  - `build` target switched to `@nx/angular:webpack-browser`.  
  - `serve` target uses `@nx/angular:dev-server`.

- Differences:   
  - Remote (`Login`): `module-federation.config.ts` uses `name` (must match project name) and `exposes` list.  
  - Host (`Dashboard`): `remotes` array lists remotes by name (e.g., `login`) and Nx resolves ports/location.

### Adding functionality & shared state
- Create a `User` data-access library (e.g., `libs/shared/data-access-user`) with an Angular service for auth state.   
- `Login` app uses this service in a form (username/password demo).   
- `Dashboard` app hides content if not authenticated, showing remote `Login` as embedded MFE.   
- Nx’s project graph & MF sharing config automatically shares the `UserService` across host/remote. 

### Converting to Dynamic MF (Dashboard host)

1. **Fetch & set remote definitions**  
   - Put `module-federation.manifest.json` in `apps/dashboard/public` describing remotes and URLs.   
   - Modify `main.ts` to:   
     - Fetch manifest (HTTP GET).  
     - Transform to format needed by `registerRemotes`.  
     - Call `registerRemotes` so MF runtime knows remote locations.

2. **Empty static `remotes`**  
   - In `apps/dashboard/module-federation.config.ts`, set `remotes: []`.   
   - Avoids build-time binding of remote URLs.

3. **Change route loading**  
   - In `app.routes.ts`, use `loadRemote` helper to lazy load remote modules based on runtime registry. 

- Result: same UX as static, but now host reads remote locations from manifest at runtime. 

### New dynamic host & remote via generators
- Generate `Employee` host preconfigured for dynamic MF, specifying `Login` as remote.   
  - Generator creates Angular app, Webpack config, MF config, MF manifest JSON, and bootstrap wiring for dynamic federation. 
- Generate `Todo` remote tied to dynamic host, which auto-updates host’s MF manifest. 

### Best practices / trade-offs
- Dynamic MF is ideal when environments are ephemeral (preview, sandboxes) or when remotes move independently but host must not be rebuilt.   
- Trade-off: added runtime complexity (manifest service, remote registry) vs compile-time simplicity of static MF. 

***

## Page 7: Angular Module Federation with SSR (high level)

*(Guide focuses on combining MF with Angular SSR; pattern is same as CSR but with server bootstrap + Node-aware MF config.)*[1]

- SSR hosts/remotes must:  
  - Configure MF for **server bundles** too (Node runtime plugin, server-specific config flags).[1]
  - Ensure remote URLs are reachable from server environment, not just browser.[1]
- Nx’s MF tooling + `NxModuleFederationPlugin` handle SSR-specific Rspack/Webpack options (e.g., Node runtime plugin, no runtime chunking).[1]

***

## Interview Cheat Sheet (Q&A Style)

**Q1: What are host and remote in Nx Module Federation?**  
- Host: loads and consumes federated modules at runtime. Remote: exposes modules to be consumed. Nx generators scaffold both and wire configs for React/Angular.[2]

**Q2: Static vs Dynamic Module Federation – when to use which?**  
- Static: host knows remote URLs at build time; simple, but requires rebuild per env. Dynamic: host reads remote URLs at runtime (manifest/endpoint), enabling “build once, deploy everywhere.” Use dynamic when remotes move per environment or across many environments.[2]

**Q3: How does Nx streamline MF setup for Angular?**  
- Generators create host/remote apps, `module-federation.config.ts`, Webpack configs, `bootstrap.ts`, and route wiring; `--host` auto-links remotes; MF configs use project graph to infer ports and share libs. 

**Q4: How are remotes served in local dev with Nx?**  
- `nx serve host` automatically builds/serves dependent remotes, typically via `serve-static` for low resource use; you can switch specific remotes to `serve` (HMR) when actively developing them. 

**Q5: How do you share state or libs across host and remotes in Nx?**  
- Put shared code into Nx libs; Nx’s project graph + MF sharing config ensures correct sharing (single instance) without manually listing every shared pkg if using Nx conventions. 

**Q6: What problems does Dynamic MF solve in CI/CD?**  
- Enables single build artifact reused across staging/prod/preview; CD pipeline just updates manifest JSON with remote URLs; no need to rebuild host for each env. 

**Q7: Describe deployment patterns for Nx MF apps.**  
- À la carte: each host/remote deploys on its own schedule. Affected: use Nx affected to test/deploy only changed ones. Need strong e2e tests and rollback; manage shared core libs carefully to avoid blocking.[1]

**Q8: How does `NxModuleFederationPlugin` help with Rspack MF?**  
- Wraps `@module-federation/enhanced`, turns on correct Rspack defaults (no runtime chunking, unique name, SSR options), configures `remoteEntry.js`, remotes, exposes, and shared libs, with runtime plugins for Node.[1]

**Q9: Where would you draw the line between MF and simple shared libs?**  
- Use MF only for independently deployable vertical slices (apps/features) or cross-app runtime sharing; use classic Nx shared libs for internal modularization within a single deployable. MF adds runtime coupling and deployment complexity. 

***

## Important Terms & Keywords (Microfrontends in Nx)

1. Module Federation, microfrontends (MFEs), runtime code sharing.   
2. Host, remote, `remoteEntry.js`.[2]
3. Static Federation, Dynamic Federation, “build once, deploy everywhere”.[2]
4. `module-federation.config.ts`, `webpack.config.ts`, `webpack.prod.config.ts`.   
5. `NxModuleFederationPlugin`, Rspack, `withModuleFederation`, `@module-federation/enhanced`.[1]
6. `serve`, `serve-static`, `webpack-dev-server`, `http-server`.   
7. Manifest file: `module-federation.manifest.json`, `registerRemotes`, `loadRemote`.   
8. Shared libraries, Nx project graph, shared state (e.g., `UserService`), TS path mappings.   
9. Independent deployability, `implicitDependencies` in `project.json`.[2]
10. À la carte deployments, affected deployments, Nx affected, CI/CD env-based URL switching (e.g., `PRODUCTION_DEPLOY` env var).[1]
11. CSR vs SSR MF, Node runtime plugins, no runtime chunking.[1]
12. `host` generator, `remote` generator, `--host` flag, dynamic host generator, dynamic remote generator.

[1](https://nx.dev/docs/technologies/module-federation/introduction)
[2](https://nx.dev/docs/technologies/module-federation/guides/create-a-host)